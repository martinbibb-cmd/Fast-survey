(function(global){
  'use strict';
  function textEncoder(){
    if (typeof TextEncoder !== 'undefined'){
      return new TextEncoder();
    }
    throw new Error('TextEncoder not available');
  }
  var encoder = textEncoder();
  var CRC_TABLE = (function(){
    var table = new Array(256);
    for (var n = 0; n < 256; n++){
      var c = n;
      for (var k = 0; k < 8; k++){
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[n] = c >>> 0;
    }
    return table;
  })();
  function crc32(arr){
    var crc = 0 ^ (-1);
    for (var i = 0; i < arr.length; i++){
      crc = (crc >>> 8) ^ CRC_TABLE[(crc ^ arr[i]) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
  }
  function toUint8(data){
    if (data instanceof Uint8Array){
      return data;
    }
    if (data instanceof ArrayBuffer){
      return new Uint8Array(data);
    }
    if (typeof data === 'string'){
      return encoder.encode(data);
    }
    throw new Error('Unsupported data type');
  }
  function viewWithLength(length){
    var buffer = new ArrayBuffer(length);
    return { view: new DataView(buffer), bytes: new Uint8Array(buffer) };
  }
  function concat(chunks){
    var total = 0;
    for (var i = 0; i < chunks.length; i++){
      total += chunks[i].length;
    }
    var out = new Uint8Array(total);
    var offset = 0;
    for (var j = 0; j < chunks.length; j++){
      out.set(chunks[j], offset);
      offset += chunks[j].length;
    }
    return out;
  }
  function encodeName(name){
    return encoder.encode(name);
  }
  function JSZip(){
    this._files = [];
  }
  JSZip.prototype.file = function(name, data){
    this._files.push({ name: name, data: data });
    return this;
  };
  JSZip.prototype.generateAsync = function(options){
    options = options || {};
    var type = options.type || 'blob';
    var files = this._files.slice();
    var promises = files.map(function(entry){
      var data = entry.data;
      if (typeof Blob !== 'undefined' && data instanceof Blob){
        return data.arrayBuffer().then(function(buffer){
          var bytes = new Uint8Array(buffer);
          return { bytes: bytes, crc: crc32(bytes), size: bytes.length };
        });
      }
      var bytes = toUint8(data);
      return Promise.resolve({ bytes: bytes, crc: crc32(bytes), size: bytes.length });
    });
    var now = new Date();
    var dosTime = ((now.getHours() << 11) | (now.getMinutes() << 5) | Math.floor(now.getSeconds() / 2)) & 0xFFFF;
    var dosDate = (((now.getFullYear() - 1980) << 9) | ((now.getMonth() + 1) << 5) | now.getDate()) & 0xFFFF;
    return Promise.all(promises).then(function(resolved){
      var localChunks = [];
      var centralChunks = [];
      var offset = 0;
      for (var i = 0; i < files.length; i++){
        var meta = resolved[i];
        var file = files[i];
        var nameBytes = encodeName(file.name);
        var local = viewWithLength(30 + nameBytes.length);
        var lv = local.view;
        lv.setUint32(0, 0x04034b50, true);
        lv.setUint16(4, 20, true);
        lv.setUint16(6, 0, true);
        lv.setUint16(8, 0, true);
        lv.setUint16(10, dosTime, true);
        lv.setUint16(12, dosDate, true);
        lv.setUint32(14, meta.crc, true);
        lv.setUint32(18, meta.size, true);
        lv.setUint32(22, meta.size, true);
        lv.setUint16(26, nameBytes.length, true);
        lv.setUint16(28, 0, true);
        local.bytes.set(nameBytes, 30);
        localChunks.push(local.bytes);
        localChunks.push(meta.bytes);
        var central = viewWithLength(46 + nameBytes.length);
        var cv = central.view;
        cv.setUint32(0, 0x02014b50, true);
        cv.setUint16(4, 20, true);
        cv.setUint16(6, 20, true);
        cv.setUint16(8, 0, true);
        cv.setUint16(10, 0, true);
        cv.setUint16(12, dosTime, true);
        cv.setUint16(14, dosDate, true);
        cv.setUint32(16, meta.crc, true);
        cv.setUint32(20, meta.size, true);
        cv.setUint32(24, meta.size, true);
        cv.setUint16(28, nameBytes.length, true);
        cv.setUint16(30, 0, true);
        cv.setUint16(32, 0, true);
        cv.setUint16(34, 0, true);
        cv.setUint16(36, 0, true);
        cv.setUint32(38, 0, true);
        cv.setUint32(42, offset, true);
        central.bytes.set(nameBytes, 46);
        centralChunks.push(central.bytes);
        offset += local.bytes.length + meta.bytes.length;
      }
      var centralData = concat(centralChunks);
      var end = viewWithLength(22);
      var ev = end.view;
      ev.setUint32(0, 0x06054b50, true);
      ev.setUint16(4, 0, true);
      ev.setUint16(6, 0, true);
      ev.setUint16(8, files.length, true);
      ev.setUint16(10, files.length, true);
      ev.setUint32(12, centralData.length, true);
      ev.setUint32(16, offset, true);
      ev.setUint16(20, 0, true);
      var archive = concat(localChunks.concat([centralData, end.bytes]));
      if (type === 'uint8array'){
        return archive;
      }
      if (type === 'arraybuffer'){
        return archive.buffer;
      }
      if (type === 'base64'){
        var str = '';
        for (var b = 0; b < archive.length; b++){
          str += String.fromCharCode(archive[b]);
        }
        return btoa(str);
      }
      return new Blob([archive], { type: 'application/zip' });
    });
  };
  global.JSZip = JSZip;
})(typeof window !== 'undefined' ? window : this);
